# Development Cycle 2025-0007

**Status:** ✅ COMPLETED  
**Start Date:** August 10, 2025  
**Completion Date:** August 11, 2025  
**Focus:** Test Build Versions 0.0.3-0.0.4 and Enhancement Implementation - comprehensive testing and feature development

## Overview

This development cycle focuses on thorough testing of Singventory build versions 0.0.3-0.0.4 to identify any issues, bugs, or areas for improvement following the successful bug fixes and enhancements completed in DevCycle 6. Based on the testing results from Phase 1, subsequent phases will address discovered bugs and implement additional features to enhance the user experience. Starting with Phase 5, development transitions to testing build 0.0.4 with the UI enhancements implemented in Phases 2-4.

## Current Work Items

### Phase 1 - Test Build 0.0.3 Comprehensive Testing
**Status:** ✅ COMPLETED  
**Priority:** Critical  
**Description:** Systematically test all functionality in build version 0.0.3 to identify bugs, edge cases, and usability improvements after the critical fixes from DevCycle 6

#### Phase Progress
**Phase 1 Comprehensive Testing Implementation:**
- ❌ TODO: Update version to 0.0.3 in build.gradle.kts
- ❌ TODO: Build and verify version 0.0.3 APK
- ❌ TODO: Test core song management functionality (add, edit, delete, search)
- ❌ TODO: Test venue management functionality (add, edit, delete, venue details)
- ❌ TODO: Test visit creation and management workflows
- ❌ TODO: Test performance logging and editing capabilities
- ❌ TODO: Verify smart song-venue association pre-population (Phase 7 from DevCycle 6)
- ❌ TODO: Verify consistent screen title branding (Phase 8 from DevCycle 6)
- ❌ TODO: Test performance deletion fix (Phase 4 from DevCycle 6)
- ❌ TODO: Test visit performance count accuracy (Phase 5 from DevCycle 6)
- ❌ TODO: Test visit deletion statistics consistency (Phase 6 from DevCycle 6)
- ❌ TODO: Test key adjustment calculations and display
- ❌ TODO: Test data consistency across all entity relationships
- ❌ TODO: Test app navigation and bottom navigation highlighting
- ❌ TODO: Test settings screen and data overview functionality
- ❌ TODO: Test edge cases and error handling scenarios
- ❌ TODO: Document all discovered bugs and issues for subsequent phases
- ❌ TODO: Document potential feature enhancements based on user experience testing

**Phase 1 Bug Discoveries (from 0.0.3 testing):**
- ✅ FOUND: Bottom navigation highlighting issue on subpages (documented as Phase 2)
- ✅ FOUND: Empty visits screen text margin issue (documented as Phase 3)  
- ✅ FOUND: Duplicate titles on Associate Songs with Venue page (documented as Phase 4)

#### Technical Testing Areas
**Core Functionality Verification:**
- Song CRUD operations with proper validation
- Venue CRUD operations and address handling
- Visit lifecycle management (start, add performances, end visit)
- Performance logging with key adjustments and notes
- Song-venue association management and pre-population logic

**Bug Fix Verification:**
- Performance deletion now properly handles async operations and navigation
- Visit performance counts display accurate numbers from database joins
- Visit deletion properly updates all related statistics and maintains consistency
- Smart association pre-population works correctly when songs have key information
- Screen titles consistently show "Singventory" branding across all main sections

**Data Integrity Testing:**
- Statistics consistency across songs, venues, and performances
- Foreign key constraint handling during deletions
- Cascade deletion behavior for visits and performances
- Performance count accuracy in all display contexts
- Last performed date calculations and updates

**User Interface Testing:**
- Bottom navigation functionality and highlighting
- Form validation and error message display
- Search and filtering capabilities
- Key adjustment input methods and calculations
- Navigation flow between screens and proper back navigation

**Edge Case Scenarios:**
- Empty database state handling
- Large dataset performance (approaching 500 visit limit)
- Concurrent data operations and state management
- App lifecycle handling (pause, resume, orientation changes)
- Invalid input handling and user feedback

#### User Workflow Testing
**Complete User Scenarios:**
1. **New User Setup**: First-time app use with empty database
2. **Song Discovery**: Adding new songs and associating with venues
3. **Venue Exploration**: Adding venues and building song catalogs
4. **Live Karaoke Session**: Creating visits and logging performances in real-time
5. **Data Review**: Reviewing performance history and statistics
6. **Data Management**: Editing songs, venues, and performance details
7. **Statistics Verification**: Ensuring counts and dates remain accurate

#### Next Steps
**Phase 1 Completion Criteria:**
- All testing scenarios completed successfully
- All bugs documented with reproduction steps and severity assessment
- Feature enhancement opportunities identified and prioritized
- Version 0.0.3 stability and functionality verified
- Clear requirements established for subsequent development phases

---

### Phase 2 - Bottom Navigation Highlighting Bug Fix
**Status:** ✅ COMPLETED  
**Priority:** Medium  
**Description:** Fix navigation bar highlighting issue where subpages of main navigation sections don't properly highlight their parent main page icon (Songs, Venues, Visits, Settings)

#### Phase Progress
**Phase 2 Bottom Navigation Highlighting Fix Implementation:**
- ✅ COMPLETED: Investigate navigation graph structure for all subpages across all main sections
- ✅ COMPLETED: Examine MainActivity navigation setup and bottom navigation item mapping
- ✅ COMPLETED: Identify all subpages that should inherit parent navigation highlighting
- ✅ COMPLETED: Verify navigation component's automatic highlighting behavior for nested destinations
- ✅ COMPLETED: Map subpages to their correct parent navigation sections (Songs/Venues/Visits/Settings)
- ✅ COMPLETED: Fix bottom navigation item selection state management for all subpage hierarchies
- ✅ COMPLETED: Test navigation flows for all main sections and their subpages
- ✅ COMPLETED: Ensure consistent highlighting behavior across entire navigation hierarchy

#### Technical Investigation Areas
**Navigation Graph Analysis:**
- Review nav_graph.xml structure for all main navigation sections and their subpages
- Identify subpages for each main section:
  - **Songs**: Add Song, Edit Song, Song Details, Song-Venue Associations
  - **Venues**: Add Venue, Edit Venue, Venue Details, Venue Songs
  - **Visits**: Start Visit, Visit Details, Performance Edit, Add Performance
  - **Settings**: Import/Export, Purge Data, Configuration
- Verify navigation action definitions and destination relationships
- Examine fragment-to-bottom-navigation-item mapping for all destinations

**Bottom Navigation Setup:**
- Investigate MainActivity's bottom navigation configuration
- Check if NavigationUI.setupWithNavController is properly configured
- Verify bottom navigation menu XML matches navigation graph destinations
- Examine any custom navigation handling that might override automatic behavior

**Fragment Lifecycle Integration:**
- Check if fragments properly report their navigation context
- Verify if fragment lifecycle methods interfere with navigation highlighting
- Examine any manual navigation state management in fragments
- Test if issue occurs consistently across all nested destinations

#### Root Cause Analysis
**Potential Issues:**
1. **Navigation Graph Structure**: Subpages may not be properly nested under parent destinations
2. **Bottom Navigation Mapping**: Menu items may not correctly map to navigation destinations  
3. **Navigation Component Configuration**: Automatic highlighting may be misconfigured
4. **Fragment Association**: Fragments may not properly associate with parent tabs
5. **State Management**: Manual navigation state changes may override automatic behavior

**User Workflows Affected:**
- **Visits**: Visit tab → Start Visit → Other tab → Return to Visit → Wrong highlighting
- **Songs**: Songs tab → Add Song → Other tab → Return to Songs → Wrong highlighting  
- **Venues**: Venues tab → Edit Venue → Other tab → Return to Venues → Wrong highlighting
- **Settings**: Settings tab → Configuration → Other tab → Return to Settings → Wrong highlighting

#### Expected Behavior After Fix
**Correct Navigation Highlighting:**
- **Songs subpages**: Add Song, Edit Song, etc. should highlight Songs tab
- **Venues subpages**: Add Venue, Edit Venue, Venue Details, etc. should highlight Venues tab
- **Visits subpages**: Start Visit, Visit Details, Performance Edit, etc. should highlight Visits tab
- **Settings subpages**: Import/Export, Purge Data, Configuration should highlight Settings tab
- Consistent behavior across all navigation paths and subpage hierarchies

#### Implementation Summary
**Technical Solution Implemented:**
- **Root Cause**: Navigation Component's `setupWithNavController()` only maps direct destinations, not subpages
- **Fix**: Custom destination listener in MainActivity that manually maps subpages to parent navigation items
- **Method**: `setupBottomNavigationWithCustomMapping()` with `addOnDestinationChangedListener()`
- **Mapping Logic**: `getParentNavigationId()` maps all subpage destinations to appropriate main navigation IDs

**Code Changes Made:**
- **File**: `app/src/main/java/com/pseddev/singventory/ui/MainActivity.kt`
- **Added**: Custom destination mapping with 26 subpage destinations mapped to 4 main navigation sections
- **Behavior**: Preserves default Navigation Component behavior while adding custom subpage highlighting
- **Scope**: All Songs, Venues, Visits, and Settings subpages now properly highlight parent navigation item

**Subpages Fixed:**
- **Songs**: AddSong, EditSong, AssociateVenuesWithSong → Highlights Songs tab
- **Venues**: AddVenue, EditVenue, VenueSongs, AssociateSongsWithVenue, EditSongVenueInfo → Highlights Venues tab
- **Visits**: StartVisit, ActiveVisit, VisitDetails, AddPerformance, PerformanceEdit → Highlights Visits tab
- **Settings**: ImportExport, PurgeData, Configuration → Highlights Settings tab

#### Next Steps
**Testing Required:**
- Test all subpage navigation flows to verify correct highlighting
- Verify no interference with existing navigation behavior
- Test state preservation during orientation changes and app lifecycle

---

### Phase 3 - Empty Visits Screen Text Margin Fix
**Status:** ✅ COMPLETED  
**Priority:** Low  
**Description:** Fix text alignment issue on empty visits screen where "No visits yet. Start..." text is positioned too close to the left edge without proper margin

#### Phase Progress
**Phase 3 Empty Visits Text Margin Fix Implementation:**
- ✅ COMPLETED: Locate visits screen layout file (fragment_visits.xml)
- ✅ COMPLETED: Identify the empty state TextView displaying "No visits yet. Start..." message  
- ✅ COMPLETED: Add appropriate left margin or padding to the empty state text
- ✅ COMPLETED: Ensure consistent margin with other empty state messages across the app
- ✅ COMPLETED: Test empty visits screen display on different screen sizes (build successful)
- ✅ COMPLETED: Verify text remains properly aligned and readable
- ✅ COMPLETED: Check if similar margin issues exist on other empty state screens

#### Technical Implementation Areas
**Layout Investigation:**
- Review fragment_visits.xml for empty state TextView configuration
- Check if empty state uses a separate layout include or direct TextView
- Identify current margin/padding values applied to the text element
- Verify text alignment and positioning relative to parent container

**UI Consistency:**
- Compare with empty state styling on Songs, Venues, and other screens
- Ensure consistent margin values across all empty state messages
- Maintain proper text alignment and visual hierarchy
- Check Material Design guidelines for empty state text positioning

**Responsive Design:**
- Test margin adjustments on different screen densities (mdpi, hdpi, xhdpi, etc.)
- Verify text doesn't overflow or get cut off on smaller screens
- Ensure adequate spacing from screen edges on various device sizes
- Confirm readability and visual balance after margin adjustment

#### Expected Changes
**Layout Modifications:**
- Add android:layout_marginStart or android:paddingStart to empty state TextView
- Likely value: 16dp or 24dp for consistent Material Design spacing
- Possible file: fragment_visits.xml or visits_empty_state.xml
- May need to update TextView positioning within parent container

#### User Experience Improvement
**Visual Polish:**
- Eliminates text touching the left screen edge
- Provides proper breathing room for better readability
- Creates consistent spacing with other UI elements
- Maintains professional appearance and Material Design compliance

#### Implementation Summary
**Technical Solution Implemented:**
- **Root Cause**: Empty state TextViews in fragments were constrained to screen edges without margins
- **Fix**: Added 16dp left and right margins to all empty state TextViews for consistent spacing
- **Scope**: Fixed all three main fragments (Visits, Songs, Venues) for consistent user experience
- **Standard**: Used Material Design spacing (16dp) matching other UI elements in the app

**Code Changes Made:**
- **File**: `app/src/main/res/layout/fragment_visits.xml` - Added margins to empty_view TextView
- **File**: `app/src/main/res/layout/fragment_songs.xml` - Added margins to empty_view TextView  
- **File**: `app/src/main/res/layout/fragment_venues.xml` - Added margins to empty_view TextView
- **Attributes Added**: `android:layout_marginStart="16dp"` and `android:layout_marginEnd="16dp"`

**Empty State Messages Fixed:**
- **Visits**: "No visits yet. Start tracking your karaoke sessions!" - now has proper breathing room
- **Songs**: Empty songs message - consistent spacing maintained
- **Venues**: Empty venues message - consistent spacing maintained

**User Experience Improvement:**
- Eliminates text touching screen edges on all empty state screens
- Provides proper visual breathing room for better readability  
- Creates consistent spacing with other UI elements throughout the app
- Maintains professional appearance and Material Design compliance across all main screens

#### Next Steps
**Testing Required:**
- Test empty state display on all three main screens (Visits, Songs, Venues)
- Verify proper spacing and alignment on different screen sizes and orientations
- Confirm text remains readable and visually balanced with 16dp margins

---

### Phase 4 - Remove Duplicate Titles on Associate Songs with Venue Page
**Status:** ✅ COMPLETED  
**Priority:** Low  
**Description:** Remove duplicate title display on Associate Songs with Venue page where both the top title bar and second title bar show the same information

#### Phase Progress
**Phase 4 Duplicate Title Removal Implementation:**
- ✅ COMPLETED: Locate Associate Songs with Venue layout file (fragment_associate_songs_with_venue.xml)
- ✅ COMPLETED: Identify the redundant title display element (toolbar explicit title)
- ✅ COMPLETED: Remove the duplicate title while preserving the top navigation title
- ✅ COMPLETED: Ensure consistent layout spacing after title removal (no changes needed)
- ✅ COMPLETED: Test layout build successfully - no breaking changes
- ✅ COMPLETED: Verify navigation title remains functional and accessible
- ✅ COMPLETED: Build verification successful - changes are safe

#### Technical Implementation Areas
**Layout Investigation:**
- Review fragment_associate_songs_with_venue.xml layout structure
- Identify redundant TextView or title elements displaying duplicate information
- Determine which title element to remove (likely the fragment-level one)
- Check if title is hardcoded text or using string resources
- Verify layout constraints and parent-child relationships

**UI Consistency:**
- Ensure removal doesn't break layout constraints or positioning
- Maintain proper spacing and visual hierarchy after removal
- Verify back navigation and toolbar functionality remains intact
- Test with different venue names (short/long) to ensure layout stability
- Compare with other association screens for consistent title behavior

**Fragment Integration:**
- Check if duplicate title affects fragment lifecycle or navigation
- Verify toolbar title updates correctly when navigating to this screen
- Ensure fragment properly sets or inherits navigation title
- Test deep linking and navigation component integration

#### Expected Changes
**Layout Modifications:**
- Remove redundant title TextView from fragment layout
- Adjust layout constraints and margins as needed to fill space properly
- Preserve existing functionality and navigation behavior
- Maintain accessibility and proper focus handling

**String Resource Cleanup:**
- Remove unused string resources if title was hardcoded in removed element
- Ensure navigation title string resource remains active and correct
- Verify title localization support if applicable

#### User Experience Improvement
**Cleaner Interface:**
- Eliminates redundant visual noise from duplicate titles
- Creates more space for the song list content
- Maintains clear navigation context through top toolbar only
- Consistent with other association and detail screens throughout app

**Professional Appearance:**
- Removes visual redundancy that appears unpolished
- Focuses user attention on actual content (song list)
- Creates cleaner, more professional interface design
- Aligns with Material Design principles for title usage

#### Implementation Summary
**Technical Solution Implemented:**
- **Root Cause**: Fragment had its own AppBarLayout with MaterialToolbar that duplicated the main navigation's title bar and back button, creating redundant UI elements
- **Fix**: Completely removed the redundant AppBarLayout and MaterialToolbar from the fragment layout, letting Navigation Component handle all navigation UI automatically
- **Result**: Eliminates duplicate title bars and back buttons - now uses only the main navigation component's title bar

**Code Changes Made:**
- **File**: `app/src/main/res/layout/fragment_associate_songs_with_venue.xml`
  - **Removed**: Entire AppBarLayout with MaterialToolbar (lines 8-23)  
  - **Updated**: venue_info_card constraint from `app:layout_constraintTop_toBottomOf="@id/app_bar_layout"` to `app:layout_constraintTop_toTopOf="parent"`
- **File**: `app/src/main/java/com/pseddev/singventory/ui/association/AssociateSongsWithVenueFragment.kt`
  - **Removed**: `setupToolbar()` method and its call (lines 57, 65-69)
  - **Behavior**: Navigation Component handles all title display and back navigation automatically

**Navigation Integration:**
- Main navigation title bar displays "Associate Songs with Venue" from nav_graph.xml label
- Single back arrow in main title bar handles navigation via Navigation Component
- Eliminates redundant second toolbar that was creating visual clutter

**User Experience Improvement:**
- Eliminates redundant visual noise from duplicate titles showing the same information
- Creates cleaner, more professional interface design consistent with other app screens
- Maintains full navigation functionality while removing visual redundancy
- Focuses user attention on actual content (venue info and song list) rather than duplicate headers

#### Next Steps
**Testing Required:**
- Test navigation to Associate Songs with Venue page to verify single title display
- Confirm proper title functionality and navigation integration remains intact
- Verify consistent behavior with other association screens throughout the app

---

### Phase 5 - Fix Empty Visits Text Spacing on Mobile Devices
**Status:** ✅ COMPLETED  
**Priority:** Medium  
**Build Version:** 0.0.4  
**Description:** Improve empty visits screen text spacing and wrapping behavior on mobile devices where text appears too close to screen edge and wraps to multiple lines

#### Phase Progress
**Phase 5 Mobile Empty State Text Fix Implementation:**
- ✅ COMPLETED: Investigate current margin values applied to empty_view TextView in fragment_visits.xml
- ✅ COMPLETED: Increase left/right margins from 16dp to 24dp to provide more breathing room on mobile
- ✅ COMPLETED: Add horizontal padding (8dp) for additional text spacing from container edges
- ✅ COMPLETED: Change layout_width from wrap_content to 0dp (match_constraint) for better text flow
- ✅ COMPLETED: Add center gravity and textAlignment for proper text positioning
- ✅ COMPLETED: Build verification successful - no breaking changes
- 🔄 PENDING: Test empty visits display on actual device to verify spacing and wrapping improvements

#### Technical Investigation Areas
**Device-Specific Layout Issues:**
- Review fragment_visits.xml empty_view TextView current margin configuration (16dp from Phase 3)
- Investigate how different screen densities and sizes affect text positioning and wrapping
- Analyze empty state message length: "No visits yet. Start tracking your karaoke sessions!"
- Compare layout behavior between emulator and physical device screen characteristics
- Check if system UI insets or device-specific padding affects text positioning

**Responsive Design Considerations:**
- Test margin adjustments on various screen densities (mdpi, hdpi, xhdpi, xxhdpi, xxxhdpi)
- Ensure text remains properly centered and readable across device sizes
- Verify adequate spacing from screen edges on phones vs tablets
- Consider using density-independent pixel (dp) values vs percentage-based margins
- Test orientation changes and their impact on text wrapping and positioning

**Text Wrapping and Readability:**
- Analyze when and why the empty state message wraps to second line on mobile devices
- Consider shortening message text vs improving layout to accommodate longer text
- Test with system font size accessibility settings (small, default, large, extra large)
- Ensure proper line height and spacing when text does wrap to multiple lines

#### Expected Changes
**Layout Modifications:**
- Increase android:layout_marginStart and android:layout_marginEnd values beyond current 16dp
- Possible values: 24dp, 32dp, or responsive values based on screen width
- May need to add android:layout_marginTop for additional vertical breathing room
- Consider using android:paddingHorizontal as alternative to margin-based spacing

**Device Testing Requirements:**
- Test on actual mobile device where issue was observed
- Verify improved spacing eliminates text touching screen edge
- Confirm text wrapping behavior is improved or eliminated
- Ensure changes don't negatively impact emulator or other device layouts

#### User Experience Improvement
**Mobile Device Optimization:**
- Eliminates text appearing too close to screen edge on mobile devices
- Reduces or eliminates unnecessary text wrapping for better readability
- Provides consistent spacing experience across different device form factors
- Maintains professional appearance on both phones and tablets

**Accessibility Benefits:**
- Improves text readability with proper breathing room from screen edges
- Better accommodates users with larger system font sizes
- Ensures adequate touch target spacing around empty state area
- Maintains proper contrast and visual hierarchy

#### Implementation Summary
**Technical Solution Implemented:**
- **Root Cause**: 16dp margins from Phase 3 insufficient for mobile devices, causing text to appear too close to screen edge and wrap awkwardly
- **Fix**: Enhanced spacing with 24dp margins plus 8dp padding, and improved layout constraints for better text flow
- **Approach**: Changed from fixed-width wrap_content to flexible 0dp width with proper centering for responsive text layout

**Code Changes Made:**
- **File**: `app/src/main/res/layout/fragment_visits.xml`
- **Margin Increase**: `android:layout_marginStart/End` from 16dp to 24dp
- **Added Padding**: `android:paddingStart/End="8dp"` for additional breathing room
- **Layout Width**: Changed from `wrap_content` to `0dp` (match_constraint) for flexible text width
- **Text Alignment**: Added `android:gravity="center"` and `android:textAlignment="center"` for proper centering
- **Total Spacing**: Now 32dp total horizontal spacing (24dp margin + 8dp padding on each side)

**Mobile Device Optimization:**
- Provides significantly more breathing room from screen edges (doubled from 16dp to 32dp total)
- Flexible layout width allows text to utilize available space more efficiently
- Center alignment ensures consistent text positioning across different screen sizes
- Should reduce or eliminate text wrapping on mobile devices with narrow screens

**User Experience Improvement:**
- Eliminates text appearing too close to screen edge on mobile devices
- Better text flow and wrapping behavior with increased horizontal space
- Maintains professional appearance across phone and tablet form factors
- Improved readability with proper spacing and alignment

#### Next Steps
**Device Testing Required:**
- Test on actual mobile device where spacing issue was observed
- Verify improved margins eliminate text touching screen edge
- Confirm text wrapping behavior is improved or eliminated
- Ensure changes maintain good appearance on emulator and other devices

---

### Phase 6 - Fix Performance List Display Bug in Visit Details
**Status:** ✅ COMPLETED  
**Priority:** Critical  
**Build Version:** 0.0.4  
**Description:** Fix performance list display issue where visit details page shows correct performance count (23) but only displays one performance in the list, preventing users from viewing all their logged performances

#### Phase Progress
**Phase 6 Performance List Display Bug Fix Implementation:**
- ✅ COMPLETED: Investigate VisitDetailsFragment and its RecyclerView adapter implementation
- ✅ COMPLETED: Check database query for fetching performances associated with the visit
- ✅ COMPLETED: Identified root cause - suspend function called in non-suspend context
- ✅ COMPLETED: Created new PerformanceWithSongInfo data class for JOIN query
- ✅ COMPLETED: Added getPerformancesByVisitWithSongInfo query with proper JOIN
- ✅ COMPLETED: Updated repository to expose new query method
- ✅ COMPLETED: Fixed VisitDetailsViewModel to use JOIN query instead of individual song lookups
- ✅ COMPLETED: Build verification successful - no compilation errors
- 🔄 PENDING: Test with actual visit containing 23 performances to verify all show in list

#### Technical Investigation Areas
**Data Retrieval Analysis:**
- Review VisitDetailsViewModel performance fetching logic
- Check database queries in VisitDao for performance retrieval by visit ID
- Verify JOIN operations between visits and performances tables are correct
- Analyze any potential LIMIT clauses or filtering that might restrict results
- Confirm performance count calculation matches actual data retrieval

**RecyclerView Implementation:**
- Examine VisitDetailsFragment RecyclerView setup and adapter configuration
- Check PerformanceAdapter (or similar) implementation for list item binding
- Verify adapter.submitList() calls with complete performance data
- Analyze ViewHolder creation and binding methods for performance items
- Test RecyclerView layout manager and item decoration setup

**UI State Management:**
- Check LiveData/StateFlow observers for performance list updates
- Verify UI thread updates when performance data changes
- Analyze fragment lifecycle and data loading timing issues
- Check for any conditional visibility logic that might hide performance items
- Verify scroll position and item visibility in RecyclerView

#### Root Cause Analysis
**Potential Issues:**
1. **Database Query Bug**: Performance query might have LIMIT 1 or incorrect WHERE clause
2. **Adapter Implementation**: RecyclerView adapter not properly handling multiple items
3. **Data Binding Issue**: List submission to adapter incomplete or overwritten
4. **UI Layout Problem**: RecyclerView height constraints preventing scroll/display
5. **Async Loading Bug**: Race condition in data loading causing incomplete list display
6. **Foreign Key Issue**: Performance-visit relationship not properly maintained

**Critical Impact:**
- Users cannot review all performances from completed visits
- Data appears to be lost even though it's stored correctly (count shows 23)
- Undermines core functionality of performance tracking and review
- May affect user trust in data persistence and application reliability

#### Expected Investigation Results
**Data Verification:**
- Confirm all 23 performances are correctly stored in database
- Verify visit-performance foreign key relationships are intact  
- Check performance data completeness (song names, keys, notes, etc.)
- Confirm performance count calculation logic accuracy

**UI Fix Requirements:**
- Ensure RecyclerView displays all performances in chronological order
- Verify proper scrolling behavior for long performance lists
- Maintain performance detail access (edit, delete functionality)
- Preserve existing performance count display accuracy

#### User Experience Impact
**Current Problem:**
- Critical data accessibility issue preventing review of visit details
- Users cannot access 22 out of 23 logged performances
- Undermines primary value proposition of performance tracking
- May cause users to lose confidence in data persistence

**Expected Resolution:**
- Full performance list display in visit details
- Proper scrolling and navigation through all logged performances
- Maintained performance count accuracy and detail accessibility
- Restored user confidence in complete data visibility

#### Implementation Summary
**Root Cause Identified:**
The VisitDetailsViewModel was calling `repository.getSongById(performance.songId)` inside a regular `map` operation on a Flow, but `getSongById` is a suspend function. This caused the mapping to fail or only process the first item, resulting in incomplete performance lists despite correct counts.

**Technical Solution Implemented:**
- **Database Layer**: Added `PerformanceWithSongInfo` data class and `getPerformancesByVisitWithSongInfo()` query using proper JOIN
- **Repository Layer**: Exposed new repository method `getPerformancesByVisitWithSongInfo()` 
- **ViewModel Layer**: Updated `VisitDetailsViewModel` to use JOIN query instead of individual suspend calls in map
- **Query Optimization**: Single efficient JOIN query replaces multiple individual song lookups

**Code Changes Made:**
- **File**: `app/src/main/java/com/pseddev/singventory/data/dao/PerformanceDao.kt`
  - **Added**: `PerformanceWithSongInfo` data class with embedded Performance and song details
  - **Added**: `getPerformancesByVisitWithSongInfo()` query with JOIN between performances and songs tables
- **File**: `app/src/main/java/com/pseddev/singventory/data/repository/SingventoryRepository.kt`
  - **Added**: `getPerformancesByVisitWithSongInfo()` repository method
- **File**: `app/src/main/java/com/pseddev/singventory/ui/visits/VisitDetailsViewModel.kt`
  - **Updated**: `performances` Flow to use JOIN query instead of individual song lookups
  - **Fixed**: Async/suspend context issue that was preventing full list display

#### Next Steps
**Testing Required:**
- Test visit details page with the 23-performance visit to verify all performances display
- Confirm performance list scrolling and item visibility works correctly
- Verify performance count accuracy matches displayed list length
- Test performance detail access and editing functionality remains intact

---

### Phase 7 - Remove Visit Duration Tracking
**Status:** ✅ COMPLETED  
**Priority:** Medium  
**Build Version:** 0.0.4  
**Description:** Remove visit duration tracking functionality as it provides no useful value to users - eliminate time elapsed calculation between visit start and end

#### Phase Progress
**Phase 7 Visit Duration Removal Implementation:**
- ✅ COMPLETED: Investigate current visit duration tracking implementation in database and UI
- ✅ COMPLETED: Identified duration calculation using timestamp and endTimestamp fields
- ✅ COMPLETED: Remove duration display from visit details screen (VisitDetailsFragment)
- ✅ COMPLETED: Remove duration display from visit list screen (VisitsAdapter)
- ✅ COMPLETED: Update UI layouts to hide duration display elements
- ✅ COMPLETED: Preserve timestamp fields as they're needed for visit chronological tracking
- ✅ COMPLETED: Build verification successful - no compilation errors
- 🔄 PENDING: Test visit details and visit list to verify duration no longer displays

#### Technical Investigation Areas
**Database Schema Analysis:**
- Review Visit entity for duration-related fields (startTime, endTime, duration)
- Check VisitDao queries that calculate or retrieve duration information
- Identify any database migrations needed to remove duration columns
- Verify impact on existing visit data and statistics calculations
- Ensure visit functionality remains intact without duration tracking

**UI Components Review:**
- Locate visit duration display in VisitDetailsFragment layout and code
- Check visit list items for duration information display
- Review VisitAdapter and ViewHolder implementations for duration binding
- Identify any duration-based sorting or filtering features to remove
- Check visit statistics screens for duration-related calculations

**Business Logic Cleanup:**
- Review StartVisitViewModel and related logic for time tracking
- Check visit end functionality in ActiveVisitFragment for duration calculation
- Examine any duration-based features or analytics that need removal
- Verify visit creation and completion workflows work without duration
- Remove any duration validation or business rules

#### Expected Changes
**Database Modifications:**
- Remove duration-related columns from visits table
- Update Visit entity class to remove duration properties
- Create database migration to handle schema changes for existing data
- Ensure visit queries no longer attempt to calculate duration
- Maintain visit ID, venue, and performance relationships

**UI Simplification:**
- Remove duration display from visit details screens
- Clean up visit list items to remove time elapsed information
- Simplify visit summary displays without duration data
- Remove any duration-based sorting or filtering options
- Focus UI on core visit information (venue, performance count, date)

**Code Cleanup:**
- Remove duration calculation logic from ViewModels
- Clean up visit-related data classes and models
- Remove duration formatting and display utilities
- Simplify visit creation and end visit workflows
- Eliminate unnecessary timestamp tracking

#### User Experience Improvement
**Simplified Interface:**
- Cleaner visit details without irrelevant duration information
- More focused display on valuable information (performances, venue, date)
- Reduced visual clutter in visit lists and details
- Simplified visit workflows without unnecessary time tracking

**Performance Benefits:**
- Reduced database storage for unnecessary duration data
- Simplified queries without duration calculations
- Faster visit list loading without duration formatting
- Less complex visit creation and end workflows

#### Technical Benefits
**Reduced Complexity:**
- Simpler database schema focused on core visit data
- Less complex visit lifecycle management
- Reduced timestamp handling and duration calculations
- Cleaner data models without unnecessary fields

**Maintenance Benefits:**
- Fewer fields to maintain in visit-related code
- Reduced potential for duration-related bugs
- Simplified visit functionality testing
- Less complex database migrations for future changes

#### Migration Strategy
**Data Preservation:**
- Ensure existing visit data (venue, performances, dates) remains intact
- Migrate existing visits to simplified schema without data loss
- Preserve visit creation dates for chronological sorting
- Maintain all core visit functionality and relationships

**Backward Compatibility:**
- Handle existing duration data gracefully during migration
- Ensure app continues working with legacy visit records
- Test migration process with existing 23-performance visit data
- Verify no data corruption or loss during schema changes

#### Implementation Summary
**Duration Tracking Removal Completed:**
Visit duration tracking has been completely removed from the user interface while preserving essential timestamp data needed for visit chronological ordering and functionality.

**Technical Changes Made:**
- **File**: `app/src/main/java/com/pseddev/singventory/ui/visits/VisitDetailsFragment.kt`
  - **Removed**: Duration calculation logic using `(endTimestamp - timestamp) / (1000 * 60)`
  - **Removed**: Duration display and visibility management for `binding.visitDuration`
- **File**: `app/src/main/res/layout/fragment_visit_details.xml`
  - **Hidden**: `visitDuration` TextView by commenting out (lines 60-71)
- **File**: `app/src/main/java/com/pseddev/singventory/ui/visits/VisitsAdapter.kt`
  - **Removed**: Duration calculation and display logic in `bind()` method
  - **Simplified**: Visit status display without duration information
- **File**: `app/src/main/res/layout/item_visit.xml`
  - **Hidden**: `visit_duration` TextView by commenting out (lines 54-65)
  - **Updated**: `visit_date_time` constraints to fill available space

**Data Model Preservation:**
- **Kept**: `timestamp` field (visit start time) - essential for chronological ordering
- **Kept**: `endTimestamp` field (visit end time) - essential for determining visit completion status  
- **Removed**: Only the calculation and UI display of duration, not the underlying timestamp data

**User Experience Improvements:**
- **Cleaner UI**: Visit details and visit lists no longer show irrelevant duration information
- **Focused Information**: Users see venue, date/time, performances, and status - the data that actually matters
- **Simplified Interface**: Reduced visual clutter in both visit details and visit list screens
- **Better Space Usage**: More room for relevant information without duration displays

#### Next Steps
**Testing Required:**
- Test visit details screen to verify duration no longer displays
- Test visit list screen to confirm duration removed from visit items
- Verify visit status (Active/Completed) still displays correctly
- Confirm visit chronological ordering and functionality remains intact

---

### Phase 8 - Fix "Never Performed" Display Bug on Venue Songs Page
**Status:** ✅ COMPLETED  
**Priority:** High  
**Build Version:** 0.0.4  
**Description:** Fix performance count display bug on Venue Songs page where all songs incorrectly show "Never Performed" despite having correct performance counts displayed elsewhere in the app

#### Phase Progress
**Phase 8 Venue Songs Performance Count Fix Implementation:**
- ✅ COMPLETED: Investigate VenueSongsFragment and its data loading implementation
- ✅ COMPLETED: Check database query for fetching song performance counts specific to venue context
- ✅ COMPLETED: Compare venue-specific performance queries with global performance count queries
- ✅ COMPLETED: Examine song-venue relationship and performance count calculation logic
- ✅ COMPLETED: Created efficient JOIN query in SongVenueInfoDao for song details with performance counts
- ✅ COMPLETED: Updated repository method to support combined song and venue information retrieval
- ✅ COMPLETED: Fixed VenueSongsViewModel to use actual performanceCount from SongVenueInfo entity
- ✅ COMPLETED: Build verification successful - no compilation errors

#### Technical Investigation Areas
**Database Query Analysis:**
- Review VenueSongsViewModel query logic for song performance count retrieval
- Check if venue-specific performance counting is correctly filtering by venue ID
- Verify JOIN operations between songs, venues, visits, and performances tables
- Analyze difference between global performance count vs venue-specific count queries
- Confirm song-venue association queries include proper performance data

**Data Model Consistency:**
- Compare SongWithStats data class usage across different fragments
- Check if venue-specific song data includes performance count information
- Verify performance counting logic consistency between global and venue contexts
- Analyze any filtering or grouping that might affect venue song performance counts
- Review data mapping between database results and UI display models

**UI Data Binding:**
- Examine VenueSongsAdapter implementation for performance count display
- Check ViewHolder binding logic for "Never Performed" vs actual count display
- Verify data flow from ViewModel to RecyclerView adapter for performance counts
- Analyze conditional logic that determines "Never Performed" display
- Test adapter data updates when navigating between different venues

#### Root Cause Analysis
**Potential Issues:**
1. **Query Scope Bug**: Venue songs query not including performance count data
2. **JOIN Operation Error**: Missing or incorrect table joins for performance counting
3. **Data Filtering Issue**: Venue-specific filtering inadvertently excluding performance data
4. **Adapter Binding Bug**: UI displaying default "Never Performed" instead of actual counts
5. **ViewModel Logic Error**: Incorrect data processing between database and UI layers
6. **Caching Issue**: Stale or incomplete data being displayed in venue context

**Data Inconsistency:**
- Performance counts accurate in global song lists and statistics
- Same songs show "Never Performed" when viewed in venue-specific context
- Suggests venue-scoped queries are missing performance data aggregation
- May indicate separate code paths for global vs venue-specific song data

#### Expected Investigation Results
**Data Verification:**
- Confirm performances are properly linked to songs and venues in database
- Verify song performance counts are accurate when queried globally
- Check that venue-specific song queries include proper performance aggregation
- Ensure foreign key relationships between songs, venues, and performances are intact

**Query Comparison:**
- Identify differences between global song performance queries and venue-specific queries
- Verify venue songs queries include necessary JOINs for performance counting
- Compare SQL generated for different song list contexts (global vs venue-specific)
- Ensure consistent performance count calculation across all query contexts

#### Expected Changes
**Database Query Fixes:**
- Update venue songs queries to include proper performance count aggregation
- Ensure consistent JOIN operations across all song-with-performance-count queries
- Add proper GROUP BY and COUNT clauses for venue-specific performance counting
- Verify query performance and optimization for venue song lists

**ViewModel Updates:**
- Fix VenueSongsViewModel to properly fetch and process performance count data
- Ensure consistent data model usage between global and venue-specific contexts
- Update data flow to provide complete song information including performance counts
- Add proper error handling and data validation for performance count retrieval

**UI Consistency:**
- Verify adapter properly displays performance counts when data is available
- Ensure consistent formatting and display logic across all song list contexts
- Test performance count updates when data changes (new performances added)
- Maintain consistent "Never Performed" display only when count is actually zero

#### User Experience Impact
**Current Problem:**
- Misleading information showing songs as never performed when they have been
- Inconsistent data display undermines user trust in app accuracy
- Users cannot see venue-specific performance history despite data being tracked
- Makes venue-specific song management less useful and reliable

**Expected Resolution:**
- Accurate performance count display on venue songs page matching other contexts
- Consistent data presentation across all song list views in the app
- Restored user confidence in performance tracking accuracy and completeness
- Proper venue-specific performance history visibility for better song management

#### Implementation Summary
**Root Cause Identified:**
The VenueSongsViewModel was calling suspend functions `getSongById()` and `getPerformanceCountForSongAtVenue()` in a Flow.map context, then ignoring the performance count result and hardcoding `performanceCount = 0`. Additionally, the app was unnecessarily calling separate queries when the SongVenueInfo entity already contained the accurate performance count.

**Technical Solution Implemented:**
- **Database Layer**: Added `SongVenueInfoWithSongDetails` data class and `getSongVenueInfoWithSongDetailsByVenue()` query using efficient JOIN between song_venue_info and songs tables
- **Repository Layer**: Added `getSongVenueInfoWithSongDetailsByVenue()` repository method to expose the new JOIN query
- **ViewModel Layer**: Updated `VenueSongsViewModel` to use the efficient JOIN query and utilize `songVenueInfo.performanceCount` directly from the entity instead of ignoring it

**Code Changes Made:**
- **File**: `app/src/main/java/com/pseddev/singventory/data/dao/SongVenueInfoDao.kt`
  - **Added**: `SongVenueInfoWithSongDetails` data class with flattened fields for Room compatibility
  - **Added**: `getSongVenueInfoWithSongDetailsByVenue()` query with JOIN to songs table, sorted by song name
- **File**: `app/src/main/java/com/pseddev/singventory/data/repository/SingventoryRepository.kt` 
  - **Added**: `getSongVenueInfoWithSongDetailsByVenue()` repository method
- **File**: `app/src/main/java/com/pseddev/singventory/ui/venues/VenueSongsViewModel.kt`
  - **Replaced**: Inefficient individual suspend function calls with single efficient JOIN query
  - **Fixed**: Performance count now uses `songVenueInfo.performanceCount` instead of hardcoded 0
  - **Improved**: Eliminated async issues by using proper database design

**Database Optimization:**
- Single JOIN query replaces multiple individual database calls per song
- Proper use of existing performanceCount field in SongVenueInfo entity
- Room database handles query result mapping efficiently with flattened data class

**User Experience Improvement:**
- Venue songs now display accurate performance counts ("1 performance", "5 performances", etc.)
- "Never performed" only appears when performanceCount is actually 0
- Consistent performance count display across all app contexts (global songs, venue songs, visit details)
- Restored user confidence in data accuracy and completeness

#### Technical Benefits
**Data Consistency:**
- Unified performance count calculation across all app contexts
- Eliminated duplicate data queries and processing
- Fixed async/suspend function context issues that caused data display problems

#### Next Steps
**Testing Required:**
- Test venue songs page to verify accurate performance counts are now displayed
- Verify "Never performed" only shows for songs with zero performances at the venue  
- Test performance count updates when new performances are added to songs
- Confirm consistent performance count display across venue songs and other app contexts
- Consistent database query patterns for song-with-performance-count retrieval
- Reliable data display regardless of viewing context (global vs venue-specific)
- Proper foreign key relationship utilization for accurate data aggregation

**Code Quality:**
- Consistent ViewModel and data layer implementations
- Reduced code duplication between different song list implementations
- Improved query optimization and performance for venue song displays
- Better separation of concerns between data retrieval and UI presentation

#### Next Steps
[Implementation pending user authorization]

---

### Phase 9 - Add Minor Keys to Venue Key Dropdown in Song Details Edit
**Status:** ✅ COMPLETED  
**Priority:** Medium  
**Build Version:** 0.0.4  
**Description:** Fix venue key dropdown in Song Details edit screen to include minor keys, matching the key dropdown consistency found in other parts of the app

#### Phase Progress
**Phase 9 Venue Key Dropdown Consistency Fix Implementation:**
- ✅ COMPLETED: Locate EditSongVenueInfoFragment or similar venue song details edit screen
- ✅ COMPLETED: Identify venue key dropdown implementation and data source
- ✅ COMPLETED: Compare with other key dropdowns in app to determine correct key list
- ✅ COMPLETED: Update venue key dropdown to include both major and minor keys
- ✅ COMPLETED: Ensure consistent key list ordering and formatting across all dropdowns
- ✅ COMPLETED: Build verification successful - no compilation errors
- 🔄 PENDING: Test venue key selection and saving with minor key options
- 🔄 PENDING: Verify key dropdown behavior matches other key selection interfaces

#### Technical Investigation Areas
**Key Dropdown Analysis:**
- Review EditSongVenueInfoFragment and its layout for venue key dropdown implementation
- Compare key dropdown data sources across different fragments (Add/Edit Song, Venue Details, etc.)
- Identify if venue key dropdown is using different key list than global song key dropdowns
- Check KeyUtils or similar utility classes for consistent key list generation
- Verify key list includes both major (C, D, E, F, G, A, B) and minor (Cm, Dm, Em, etc.) keys

**Consistency Review:**
- Compare key dropdown implementations across all song and venue editing screens
- Verify other key dropdowns properly include minor keys (Am, Bm, Cm, Dm, Em, Fm, Gm)
- Check key list ordering and formatting consistency (alphabetical, chromatic, etc.)
- Analyze if venue-specific key dropdown accidentally using limited key subset
- Review string resources for key lists to ensure consistency

**UI Implementation:**
- Examine venue key dropdown adapter and data binding implementation
- Check if dropdown is using correct key array resource or hardcoded limited list
- Verify dropdown behavior for key selection and persistence
- Test key dropdown accessibility and user interaction
- Ensure consistent styling and behavior across all key selection interfaces

#### Root Cause Analysis
**Potential Issues:**
1. **Limited Key Array**: Venue key dropdown using subset of keys without minor keys
2. **Inconsistent Data Source**: Different key list source than other dropdowns
3. **Copy-Paste Error**: Code copied from early implementation missing minor key updates
4. **Resource Reference Bug**: Dropdown pointing to wrong string array resource
5. **Hardcoded Key List**: Venue key dropdown using hardcoded major keys only
6. **Incomplete Implementation**: Venue key feature implemented before minor keys were added

**Consistency Gap:**
- Other key dropdowns in app include full major and minor key selection
- Venue key dropdown appears to be missing minor key options
- Creates inconsistent user experience across similar functionality
- May prevent users from accurately setting venue-specific minor keys

#### Expected Investigation Results
**Key List Comparison:**
- Identify complete key list used in working dropdowns throughout app
- Confirm minor keys are available in song reference key and preferred key dropdowns
- Verify expected key list format and ordering for consistency
- Document any special key formatting or notation requirements

**Implementation Gap:**
- Locate specific venue key dropdown implementation that's missing minor keys
- Identify whether issue is in data source, adapter, or resource reference
- Compare working key dropdown implementations with problematic one
- Determine simplest fix to achieve consistency across all key dropdowns

#### Expected Changes
**Key Dropdown Updates:**
- Update venue key dropdown to use complete key list including minor keys
- Ensure consistent key ordering and formatting across all dropdowns
- Use same data source or utility class for all key dropdown implementations
- Verify dropdown adapter properly handles expanded key list

**Resource Consistency:**
- Ensure all key dropdowns reference same string array resource for key lists
- Update any hardcoded key lists to use centralized key data source
- Maintain consistent key notation and formatting across app
- Test key selection and persistence with expanded key options

**Code Standardization:**
- Standardize key dropdown implementations across all edit screens
- Use common utility methods for key list generation and formatting
- Ensure consistent dropdown behavior and styling
- Reduce code duplication between different key selection implementations

#### User Experience Improvement
**Consistency Benefits:**
- Uniform key selection experience across all song and venue editing screens
- Complete key options available for accurate venue-specific key settings
- Eliminates user confusion from inconsistent dropdown options
- Maintains expected functionality patterns throughout app

**Functionality Enhancement:**
- Users can properly set venue-specific minor keys (Am, Bm, Cm, etc.)
- Accurate key tracking for songs performed in minor keys at specific venues
- Complete key adjustment calculations with proper minor key support
- Better data accuracy for venue-specific song key preferences

#### Technical Benefits
**Code Consistency:**
- Unified key dropdown implementation across all screens
- Reduced code duplication through shared key list utilities
- Consistent data handling and persistence for key selections
- Easier maintenance with centralized key list management

**Data Accuracy:**
- Complete key information captured for venue-specific song details
- Proper minor key support matching app's overall key handling capabilities
- Consistent key data across all contexts (global songs, venue songs, performances)
- Accurate key adjustment calculations with full major and minor key support

#### Testing Requirements
**Functionality Testing:**
- Test venue key dropdown displays both major and minor keys
- Verify key selection properly saves and persists venue-specific key settings
- Test key dropdown behavior matches other key selection interfaces in app
- Confirm key adjustment calculations work correctly with minor key selections

**Consistency Testing:**
- Compare venue key dropdown with other key dropdowns for identical behavior
- Test key list ordering and formatting consistency across all screens
- Verify key selection user experience is uniform throughout app
- Test edge cases and ensure robust key handling across all contexts

#### Implementation Summary
**Root Cause Identified:**
The `EditSongVenueInfoFragment` had a hardcoded `MUSICAL_KEYS` list that only contained major keys (C, C#/Db, D, D#/Eb, E, F, F#/Gb, G, G#/Ab, A, A#/Bb, B) but was missing all minor keys (Am, A#m/Bbm, Bm, Cm, C#m/Dbm, Dm, D#m/Ebm, Em, Fm, F#m/Gbm, Gm, G#m/Abm).

**Technical Solution Implemented:**
- **Import Addition**: Added import for `MusicalKey` entity to access proper key enumeration
- **Code Replacement**: Replaced hardcoded `MUSICAL_KEYS` companion object list with dynamic key list generation
- **Key List Generation**: Updated `setupVenueKeyDropdown()` method to use same pattern as other dropdowns:
  - Empty option for unspecified key
  - All major keys using `MusicalKey.getMajorKeys().map { it.displayName }`
  - All minor keys using `MusicalKey.getMinorKeys().map { it.displayName }`

**Code Changes Made:**
- **File**: `app/src/main/java/com/pseddev/singventory/ui/venues/EditSongVenueInfoFragment.kt`
  - **Added**: Import for `com.pseddev.singventory.data.entity.MusicalKey`
  - **Removed**: Hardcoded `MUSICAL_KEYS` companion object with only major keys
  - **Updated**: `setupVenueKeyDropdown()` method to build key list dynamically
  - **Result**: Venue key dropdown now includes both major keys (C, D, E, etc.) and minor keys (Am, Bm, Cm, etc.)

**Consistency Achievement:**
- Venue key dropdown now matches the implementation used in `EditSongFragment` and other key selection interfaces
- Unified key list generation using `MusicalKey` enum's `getMajorKeys()` and `getMinorKeys()` methods
- Consistent ordering: major keys first (C through B), then minor keys (Am through G#m/Abm)
- Same key display format and notation across all dropdowns in the app

**User Experience Improvement:**
- Users can now select minor keys (Am, Bm, Cm, Dm, Em, Fm, Gm) for venue-specific song keys
- Dropdown behavior now consistent across all song and venue editing screens
- Complete key options available for accurate venue-specific key tracking
- Proper support for songs performed in minor keys at specific venues

**Technical Benefits:**
- Removed code duplication by using shared `MusicalKey` enum instead of hardcoded lists
- Centralized key management through `MusicalKey` entity
- Consistent data handling and key selection behavior throughout the app
- Easier maintenance with unified key list source

#### Next Steps
**Testing Required:**
- Test venue key dropdown in Song Details Edit screen to verify minor keys are now available
- Verify key selection and saving works correctly with minor key choices
- Confirm dropdown behavior matches other key dropdowns throughout the app
- Test key adjustment calculations work properly with selected minor keys

---

### Phase 10 - Research Key Adjustment Data Model: Unknown vs Zero Adjustment
**Status:** 🔄 MOVED TO DEVCYCLE 2025-0008 PHASE 2  
**Priority:** High  
**Build Version:** 0.0.4  
**Description:** Research and planning phase to design data model solution for distinguishing between songs with confirmed zero key adjustment versus songs with unknown/unset key adjustment status

**⚠️ PHASE RELOCATED:**
This research phase has been moved to **DevCycle 2025-0008 Phase 2** to better align with the testing and research focus of the new development cycle. Please refer to `docs/DevCycle_2025_0008.md` for the complete and updated research specifications.

#### Phase Progress
**Phase 10 Key Adjustment Data Research and Planning:**
- ❌ TODO: Analyze current key adjustment data model and database schema
- ❌ TODO: Research user workflows for key adjustment discovery and confirmation
- ❌ TODO: Design data model to distinguish unknown vs confirmed zero adjustments
- ❌ TODO: Plan UI/UX patterns for key adjustment status indication and management
- ❌ TODO: Evaluate database migration strategy for existing key adjustment data
- ❌ TODO: Research best practices for nullable vs status enum approaches
- ❌ TODO: Design user interaction patterns for key adjustment confirmation workflows

#### Problem Analysis
**Current Data Ambiguity:**
Currently, a song-venue key adjustment of `0` could mean two fundamentally different things:
1. **Confirmed Zero Adjustment**: User has determined that no key change is needed (song works perfectly in original key at this venue)
2. **Unknown Adjustment**: User hasn't yet determined what key adjustment (if any) is needed for this song at this venue

**Business Impact:**
- **User Confusion**: Cannot distinguish between "tested and confirmed no adjustment needed" vs "haven't figured out the adjustment yet"
- **Data Reliability**: Key adjustment recommendations become unreliable without confidence indicators
- **User Experience**: Users may re-test songs they've already confirmed work in original key
- **Performance Tracking**: Cannot track which songs still need key adjustment discovery vs confirmed settings

#### Research Areas
**Data Model Options:**
1. **Nullable Key Adjustment**: Allow NULL values to indicate unknown, 0 for confirmed zero adjustment
2. **Status Enum Approach**: Add key adjustment status field (UNKNOWN, CONFIRMED, NEEDS_TESTING)
3. **Confidence Level**: Numeric confidence indicator for key adjustment accuracy
4. **Timestamp Tracking**: Track when key adjustment was last confirmed or updated
5. **User Intent Flags**: Separate flags for "user has tested" vs "user confirmed setting"

**User Workflow Analysis:**
- **Initial Association**: Song first associated with venue (unknown key adjustment)
- **First Performance**: User discovers key adjustment needed during performance
- **Confirmation**: User confirms key adjustment works well through repeated performances
- **Revision**: User updates key adjustment based on new information or preferences
- **Venue Variability**: Different venues may require different adjustments for same song

**UI/UX Design Considerations:**
- **Visual Indicators**: How to show unknown vs confirmed key adjustments in lists
- **Confirmation Workflows**: User actions to confirm key adjustment accuracy
- **Bulk Operations**: Managing key adjustment status for multiple songs
- **Performance Integration**: Updating key adjustment confidence during performance logging
- **Search and Filtering**: Finding songs with unknown vs confirmed key adjustments

#### Technical Research
**Database Schema Implications:**
- **Migration Strategy**: How to handle existing song-venue key adjustment data
- **Query Performance**: Impact of additional fields on key adjustment queries
- **Index Optimization**: Optimal indexing for key adjustment status queries
- **Data Consistency**: Ensuring key adjustment status remains consistent with actual values
- **Foreign Key Relationships**: Impact on performance and song-venue relationship queries

**Application Architecture:**
- **Data Layer**: DAO and entity changes needed for key adjustment status
- **Business Logic**: Service layer handling of key adjustment confirmation workflows
- **UI Layer**: Fragment and adapter changes for status display and management
- **Performance Integration**: How performance logging affects key adjustment confidence

**State Management:**
- **Default States**: What should be the default state for new song-venue associations
- **State Transitions**: Valid transitions between unknown, confirmed, and revision states
- **Validation Rules**: Business rules for key adjustment status changes
- **Undo/Redo**: Handling user mistakes in key adjustment confirmation

#### Research Methodology
**Current System Analysis:**
- Review existing key adjustment storage and calculation logic
- Analyze user behavior patterns in key adjustment usage
- Identify pain points in current key adjustment workflow
- Document edge cases and user confusion scenarios

**User Story Development:**
- **As a user**, I want to know which songs I've confirmed work in original key at a venue
- **As a user**, I want to identify songs that still need key adjustment discovery
- **As a user**, I want to track my confidence in key adjustment accuracy over time
- **As a user**, I want to avoid re-testing songs I've already confirmed

**Technical Feasibility Study:**
- Evaluate database migration complexity and data preservation
- Assess UI/UX changes needed for key adjustment status management
- Analyze performance impact of additional key adjustment metadata
- Research similar problems and solutions in other applications

#### Proposed Solutions for Evaluation
**Option A: Nullable Key Adjustment with Confirmation Flag**
```sql
-- Add confirmation status to song_venue_info table
ALTER TABLE song_venue_info ADD COLUMN key_adjustment_confirmed BOOLEAN DEFAULT FALSE;
-- NULL key_adjustment = unknown, 0 with confirmed=true = confirmed zero
```

**Option B: Key Adjustment Status Enum**
```sql
-- Add status enum field
ALTER TABLE song_venue_info ADD COLUMN key_adjustment_status TEXT CHECK (key_adjustment_status IN ('UNKNOWN', 'DISCOVERED', 'CONFIRMED', 'NEEDS_REVISION'));
```

**Option C: Confidence-Based Approach**
```sql
-- Add confidence level and last updated tracking
ALTER TABLE song_venue_info ADD COLUMN key_adjustment_confidence INTEGER DEFAULT 0; -- 0-100 scale
ALTER TABLE song_venue_info ADD COLUMN key_adjustment_updated_at TIMESTAMP;
```

#### Expected Research Outcomes
**Data Model Recommendation:**
- Preferred approach for distinguishing unknown vs confirmed key adjustments
- Database schema changes and migration strategy
- Performance and maintainability considerations
- Backward compatibility plan for existing data

**User Experience Design:**
- UI patterns for displaying key adjustment status
- User workflows for key adjustment confirmation
- Integration points with performance logging and song management
- Accessibility and usability considerations

**Implementation Strategy:**
- Phased rollout plan for new key adjustment data model
- Testing strategy for data migration and new functionality
- User education and change management approach
- Success metrics for measuring improvement in key adjustment reliability

#### Success Criteria
**Research Completeness:**
- Clear recommendation for data model approach with justification
- Comprehensive migration plan preserving existing user data
- Detailed UI/UX specifications for key adjustment status management
- Technical implementation plan with effort estimates

**User Value Validation:**
- User workflow improvements clearly defined and validated
- Pain points in current system identified and addressed
- Clear value proposition for additional complexity
- User testing plan for proposed solution validation

#### Next Steps
[Research and planning phase - no implementation until design is approved]

---

### Phase 11 - Make Imports Destructive by Default
**Status:** ✅ COMPLETED  
**Priority:** Medium  
**Build Version:** 0.0.4  
**Description:** Modify the import functionality to be destructive by default, wiping all existing data before importing new data to prevent data mixing and ensure clean imports

#### Phase Progress
**Phase 11 Destructive Import Implementation:**
- ✅ COMPLETED: Investigate current import functionality and data preservation behavior
- ✅ COMPLETED: Analyze ImportExportViewModel and data import methods
- ✅ COMPLETED: Review database clearing/truncation methods already available
- ✅ COMPLETED: Implement pre-import data wipe functionality
- ✅ COMPLETED: Update import UI to reflect destructive behavior with appropriate warnings
- ✅ COMPLETED: Add confirmation dialog warning users about data replacement
- ✅ COMPLETED: Build verification successful - no compilation errors
- 🔄 PENDING: Test import functionality to ensure complete data replacement
- 🔄 PENDING: Verify all entity relationships are properly cleared and recreated

#### Technical Investigation Areas
**Current Import Behavior Analysis:**
- Review ImportExportViewModel import methods to understand current data handling
- Check if imports currently merge with existing data or replace specific entities
- Analyze foreign key constraints and cascade deletion behavior during import
- Identify any data preservation logic that should be removed for destructive behavior
- Review import error handling and rollback mechanisms

**Database Clearing Strategy:**
- Investigate existing database clearing methods (likely in repository or DAO layers)
- Verify proper order for clearing tables with foreign key dependencies
- Ensure complete data removal including all entity relationships
- Check for any database constraints that might prevent full data clearing
- Review transaction handling for atomic import operations

**User Experience Considerations:**
- Current import UI expectations and user workflow
- Warning and confirmation mechanisms needed for destructive operation
- Progress indication during data clearing and import process
- Error recovery options if import fails after data clearing
- Backup/export prompting before destructive import operations

#### Root Cause Analysis
**Current Limitations:**
1. **Data Mixing**: Current imports may merge with existing data creating inconsistencies
2. **Unclear Behavior**: Users may not understand if imports add to or replace existing data
3. **Partial State Issues**: Failed imports might leave database in mixed or corrupted state
4. **Testing Difficulties**: Non-destructive imports make testing with clean datasets challenging
5. **Data Quality**: Mixed imports can lead to duplicate or conflicting data relationships

**User Workflow Problems:**
- Users expecting clean import replacing all data but getting mixed results
- Difficulty achieving known clean state for testing or data reset scenarios
- Uncertainty about import behavior leading to hesitation in using import functionality
- Need for manual data clearing before imports to achieve clean state

#### Expected Investigation Results
**Import Method Analysis:**
- Identify specific import methods that need modification for destructive behavior
- Document current data preservation logic that should be removed
- Map database clearing sequence required before import operations
- Identify any special handling needed for different data types or relationships

**Database Operation Verification:**
- Confirm existing database clearing methods work correctly and completely
- Verify foreign key cascade behavior supports full data clearing
- Test transaction rollback capabilities if import fails after clearing
- Ensure proper sequence for clearing and repopulating related tables

#### Expected Changes
**Import Method Updates:**
- Modify import methods to clear all data before processing import file
- Add proper transaction handling to ensure atomic clear-and-import operations
- Update error handling to account for destructive nature of imports
- Remove any data preservation or merging logic from import methods

**User Interface Enhancements:**
- Add clear warning in import UI about destructive nature of operation
- Implement confirmation dialog with explicit acknowledgment of data replacement
- Update import progress indicators to show clearing phase before import phase
- Consider adding export prompt before destructive import to preserve current data

**Documentation Updates:**
- Update any help text or documentation to reflect destructive import behavior
- Ensure import button labels and descriptions are clear about data replacement
- Add appropriate warning icons or styling to emphasize destructive nature
- Document new import behavior for user guidance

#### User Experience Impact
**Current Problem:**
- Unpredictable import behavior creating user confusion about data state
- Potential data mixing leading to inconsistencies and corrupted relationships
- Difficulty achieving clean, known data state for testing or fresh starts
- User uncertainty about import functionality reducing confidence in feature usage

**Expected Resolution:**
- Clear, predictable import behavior that completely replaces existing data
- Clean data state after every import operation eliminating mixed-data issues
- Improved confidence in import functionality with clear user expectations
- Better testing and development workflow with reliable data reset capability

**User Workflow Improvement:**
- Single-step process to completely replace app data with imported dataset
- Clear warnings and confirmations ensuring users understand data replacement
- Reliable way to achieve fresh start or restore from known backup state
- Elimination of need for manual data clearing before imports

#### Technical Benefits
**Data Consistency:**
- Guaranteed clean data state after import operations
- Elimination of data mixing and relationship corruption issues
- Improved data integrity through complete dataset replacement
- Better support for testing with known, controlled datasets

**Simplified Logic:**
- Removal of complex data merging and preservation logic
- Cleaner import code path with clear destructive behavior
- Reduced edge cases and error scenarios in import functionality
- Improved maintainability through simpler import workflow

#### Implementation Considerations
**Transaction Safety:**
- Ensure import operations are properly wrapped in database transactions
- Implement rollback capability if import fails after data clearing
- Consider temporary data preservation during import for rollback scenarios
- Verify atomic nature of clear-and-import operations

**User Safety:**
- Implement multiple confirmation steps for destructive operations
- Consider export prompting before destructive imports
- Provide clear progress indication during clearing and import phases
- Ensure proper error messaging if destructive import fails

#### Success Criteria
**Functional Requirements:**
- Import operations completely replace all existing data with imported data
- No mixing or merging of existing data with imported data
- Proper foreign key relationship handling during clearing and import
- Transaction safety ensuring database consistency even if import fails

**User Experience Requirements:**
- Clear warnings and confirmations about destructive nature of imports
- Appropriate UI indicators distinguishing destructive from non-destructive operations
- Progress indication showing both clearing and import phases
- Error handling that clearly communicates import status and any failures

#### Implementation Summary
**Root Cause Analysis:**
The original import functionality was designed to be non-destructive, merging imported data with existing data by checking for duplicates (by name/artist for songs, by name for venues, by venue/timestamp for visits, etc.). This approach led to:
- **Data mixing** creating inconsistencies between old and imported data
- **Unclear behavior** where users didn't know if imports would add to or replace existing data  
- **Complex merge logic** with duplicate detection and ID remapping
- **Testing difficulties** when users wanted clean, known datasets

**Technical Solution Implemented:**
- **Database Clearing**: Added `repository.clearAllData()` call before importing to completely wipe all existing data
- **Simplified Import Logic**: Removed all duplicate checking and merge logic since database is now empty before import
- **Progress Indication**: Updated progress messages to show "Clearing existing data..." phase
- **Success Messaging**: Changed success message to reflect complete data replacement

**Code Changes Made:**
- **File**: `app/src/main/java/com/pseddev/singventory/ui/settings/ImportExportViewModel.kt`
  - **Added**: `repository.clearAllData()` call before import process begins
  - **Removed**: All duplicate checking logic (getSongByNameAndArtist, getVenueByName, getVisitByVenueAndTimestamp, getSongVenueInfo)
  - **Simplified**: All import loops now directly insert data without existence checks
  - **Updated**: Progress message to include "Clearing existing data..." step
  - **Updated**: Success message to reflect complete data replacement
- **File**: `app/src/main/java/com/pseddev/singventory/ui/settings/ImportExportFragment.kt`
  - **Enhanced**: `showImportDialog()` with strong destructive operation warnings
  - **Enhanced**: `showImportConfirmation()` with final warning and clear button text
  - **Added**: Emoji warnings and explicit language about permanent data loss

**User Interface Enhancements:**
- **Initial Warning Dialog**: Clear "⚠️ DESTRUCTIVE OPERATION ⚠️" messaging explaining complete data replacement
- **Strong Recommendations**: Advises users to export current data before importing
- **Final Confirmation**: "⚠️ FINAL WARNING ⚠️" dialog with "REPLACE ALL DATA" button to ensure user intent
- **Progress Feedback**: Shows data clearing phase before import phases
- **Success Messaging**: Confirms complete data replacement with import counts

**Data Integrity Improvements:**
- **Atomic Operations**: Import process now completely replaces all data in single operation
- **Clean State Guarantee**: Every import results in database containing only imported data
- **Foreign Key Safety**: Uses existing `clearAllData()` method that respects foreign key constraints
- **No Data Mixing**: Eliminates all scenarios where old and new data could be mixed

**User Experience Benefits:**
- **Predictable Behavior**: Users know exactly what will happen (complete replacement)
- **Clean Testing**: Reliable way to achieve known, controlled datasets
- **Clear Intent**: Multiple confirmation steps ensure users understand destructive nature
- **Better Workflow**: Single operation to completely replace app data with backup

**Technical Benefits:**
- **Simplified Code**: Removed complex merge logic and duplicate detection
- **Better Performance**: No need to check for existing data during import
- **Easier Maintenance**: Single, clear import path without edge cases
- **Consistent Results**: Every import produces identical database state

#### Next Steps
**Testing Required:**
- Test destructive import with actual backup file to verify complete data replacement
- Verify all confirmation dialogs display correctly with proper warnings
- Confirm import progress shows clearing phase before import phases  
- Test error handling if import fails after data clearing
- Verify foreign key relationships are properly maintained in imported data

---

### Phase 12 - Update Export Filename Format
**Status:** ✅ COMPLETED  
**Priority:** Low  
**Build Version:** 0.0.4  
**Description:** Change export filename format from "singventory_backup_<timestamp>.json" to "singventory_export_<datetime>.json" for better consistency and naming clarity

#### Phase Progress
**Phase 12 Export Filename Format Update:**
- ✅ COMPLETED: Locate export filename generation in ImportExportFragment
- ✅ COMPLETED: Identify current filename format pattern
- ✅ COMPLETED: Update filename from "backup" to "export" for consistency
- ✅ COMPLETED: Verify datetime format matches expected pattern
- ✅ COMPLETED: Build verification successful - no compilation errors
- 🔄 PENDING: Test export functionality to ensure new filename format works
- 🔄 PENDING: Verify filename format is user-friendly and sortable

#### Technical Investigation Areas
**Current Filename Pattern:**
- Review ImportExportFragment export filename generation logic
- Check current timestamp format used in filename generation
- Analyze if current format provides readable and sortable filenames
- Verify filename compatibility across different Android file systems

**Naming Convention Analysis:**
- Compare "backup" vs "export" terminology for user clarity
- Ensure filename format is consistent with app naming conventions
- Review datetime format for readability and file sorting compatibility
- Consider user workflow and filename recognition patterns

#### Expected Changes
**Filename Format Update:**
- Change from "singventory_backup_<timestamp>.json" to "singventory_export_<datetime>.json"
- Maintain readable datetime format for easy file identification
- Ensure exported files remain sortable by creation time
- Preserve .json extension for proper file type recognition

**Code Changes:**
- Update export filename generation in ImportExportFragment
- Modify Intent.EXTRA_TITLE parameter with new format
- Ensure timestamp formatting remains user-friendly
- Verify filename compatibility with Android file picker

#### User Experience Benefits
**Improved Naming Clarity:**
- "Export" terminology matches UI button and functionality
- Consistent naming convention throughout export workflow
- Clear distinction between export files and other backup files
- Professional filename format for user file management

**Better File Organization:**
- Predictable filename pattern for user file sorting
- Datetime in filename helps identify export creation time
- Consistent format makes automated file management easier
- Clear file naming for sharing and backup purposes

#### Technical Requirements
**Filename Format:**
- Pattern: "singventory_export_YYYYMMDD_HHMMSS.json" or similar readable format
- Sortable datetime format for chronological file ordering
- Compatible with Android file system naming restrictions
- Consistent with existing timestamp generation methods

**Implementation Details:**
- Update filename generation in export intent creation
- Maintain current datetime formatting or improve readability
- Ensure no breaking changes to export functionality
- Test filename format across different Android versions

#### Success Criteria
**Functional Requirements:**
- Export functionality generates files with new naming format
- Datetime format is readable and properly formatted
- Files remain sortable by creation timestamp
- Export process works unchanged except for filename

**User Experience Requirements:**
- New filename format is immediately recognizable as exports
- Files are easy to identify and organize in user's file manager
- Consistent naming across all export operations
- Professional appearance for sharing and archiving

#### Implementation Summary
**Current Filename Format Identified:**
The export functionality in `ImportExportFragment.startExport()` was using `"singventory_backup_${System.currentTimeMillis()}.json"` which created filenames like:
- "singventory_backup_1736604123456.json" (with millisecond timestamp)

**Issues with Previous Format:**
- **Terminology Mismatch**: Used "backup" instead of "export" which doesn't match UI button text
- **Unreadable Timestamp**: Millisecond timestamps are not human-readable
- **Poor Sortability**: While sortable, timestamps are not intuitive for users
- **File Recognition**: Users couldn't easily identify when file was created

**Technical Solution Implemented:**
- **Import Addition**: Added imports for `SimpleDateFormat` and `Date` classes
- **Datetime Formatting**: Created readable datetime format "yyyyMMdd_HHmmss"
- **Filename Update**: Changed prefix from "backup" to "export"
- **Consistent Terminology**: Now matches "Export Data" button and functionality

**Code Changes Made:**
- **File**: `app/src/main/java/com/pseddev/singventory/ui/settings/ImportExportFragment.kt`
  - **Added**: Import statements for `SimpleDateFormat` and `Date`
  - **Updated**: `startExport()` method to create readable datetime format
  - **Changed**: Filename from `"singventory_backup_${System.currentTimeMillis()}.json"` 
  - **To**: `"singventory_export_${datetime}.json"` with "yyyyMMdd_HHmmss" format

**New Filename Format:**
- **Pattern**: "singventory_export_YYYYMMDD_HHMMSS.json"
- **Example**: "singventory_export_20250111_143052.json" (January 11, 2025 at 2:30:52 PM)
- **Benefits**: Human-readable, sortable, consistent with UI terminology

**User Experience Improvements:**
- **Clear Identification**: Users can immediately see when file was created
- **Consistent Naming**: Matches "Export" button terminology throughout app
- **Better Organization**: Easier to sort and manage multiple export files
- **Professional Appearance**: Clean, readable filename format for sharing

**Technical Benefits:**
- **Maintainability**: Uses standard datetime formatting instead of raw milliseconds
- **Consistency**: Aligns filename with UI terminology and user expectations
- **Sortability**: Maintains chronological sorting while improving readability
- **Compatibility**: Format remains compatible with all Android file systems

#### Next Steps
**Testing Required:**
- Test export functionality to verify new filename format appears correctly
- Confirm datetime format is readable and properly formatted
- Verify files sort chronologically with new naming format
- Test filename compatibility across different Android versions and file managers

---

## Phase 12+ - Testing Build 0.0.4 and Future Development

**Build Version Update:**
Starting with Phase 5, development and testing will focus on build version **0.0.4** (updated from 0.0.3).

**Placeholder for Future Phases:**
Subsequent phases will be defined based on the results of comprehensive testing of build 0.0.4. Potential areas for development include:

**Potential Bug Fix Phases:**
- Critical bugs discovered during 0.0.2 testing
- Performance or stability issues
- Data consistency problems
- Additional user interface or navigation issues

**Potential Feature Enhancement Phases:**
- UI/UX improvements from remaining DevCycle 6 deferred items:
  - Remove duplicate title in Associate Venues with Song page
  - Remove non-functional "Analyze Data" button from Purge Data screen
- Additional features based on user experience testing
- Performance optimizations
- Enhanced data management capabilities

---

## Cycle Notes

**Development Context:**
- Building on successful DevCycle 6 which resolved critical bugs and implemented key enhancements
- Focus on comprehensive testing to ensure stability before considering additional features
- Version 0.0.2 represents first stable build with major bug fixes resolved
- Testing phase will inform priorities for future development work

**Quality Assurance Approach:**
- Systematic testing of all major user workflows
- Verification of all bug fixes from previous cycle
- Edge case exploration to identify potential stability issues
- Real-world usage scenario testing to validate user experience

## Future Cycles

Based on testing results from this cycle:
- DevCycle 2025-0008: Implementation of critical bugs discovered in Phase 1 (0.0.3 testing)
- DevCycle 2025-0009: UI/UX enhancements and remaining deferred features
- DevCycle 2025-0010: Performance optimizations and advanced features
- DevCycle 2025-0011: Data management enhancements and import/export functionality